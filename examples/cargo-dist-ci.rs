use grackle::{Job, JobStep, PullRequest, Push, Strategy, Workflow};

fn main() {
    let wf = Workflow::builder()
        .name("Release")
        .contents_write_permission()
        .on_push(Push::builder().tag("**[0-9]+.[0-9]+.[0-9]+*").build())
        .on_pull_request(PullRequest::builder().build())
        .add_job("plan", Job::builder()
            .runs_on("ubuntu-latest")
            .output("val", "${{ steps.plan.outputs.manifest }}")
            .output("tag", "${{ !github.event.pull_request && github.ref_name || '' }}")
            .output("tag-flag", "${{ !github.event.pull_request && format('--tag={0}', github.ref_name) || '' }}")
            .output("publishing", "${{ !github.event.pull_request }}")
            .env_var("GH_TOKEN", "${{ secrets.GITHUB_TOKEN }}")
            .add_step(JobStep::builder()
                .uses("actions/checkout@v4")
                .with("submodules", "recursive")
                .build())
            .add_step(JobStep::builder()
                .name("Install cargo-dist")
                .shell("bash")
                .run("curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.14.1/cargo-dist-installer.sh | sh")
                .build())
            .add_step(JobStep::builder()
                .id("plan")
                .run(r#"cargo dist ${{ (!github.event.pull_request && format('host --steps=create --tag={0}', github.ref_name)) || 'plan' }} --output-format=json > plan-dist-manifest.json
echo "cargo dist ran successfully"
cat plan-dist-manifest.json
echo "manifest=$(jq -c "." plan-dist-manifest.json)" >> "$GITHUB_OUTPUT""#)
                .build())
            .add_step(JobStep::builder()
                .name("Upload dist-manifest.json")
                .uses("actions/upload-artifact@v4")
                .with("name", "artifacts-plan-dist-manifest")
                .with("path", "plan-dist-manifest.json")
                .build())
            .build())
        .add_job("build-local-artifacts", Job::builder()
            .name("build-local-artifacts (${{ join(matrix.targets, ', ') }})")
            .needs("plan")
            .if_cond("${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix.include != null && (needs.plan.outputs.publishing == 'true' || fromJson(needs.plan.outputs.val).ci.github.pr_run_mode == 'upload') }}")
            .strategy(Strategy::builder()
                .fail_fast(false)
                .matrix_expr("${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix }}")
                .build())
            .runs_on("${{ matrix.runner }}")
            .env_var("GH_TOKEN", "${{ secrets.GITHUB_TOKEN }}")
            .env_var("BUILD_MANIFEST_NAME", "target/distrib/${{ join(matrix.targets, '-') }}-dist-manifest.json")
            .add_step(JobStep::builder()
                .name("enable windows longpaths")
                .run("git config --global core.longpaths true")
                .build())
            .add_step(JobStep::builder()
                .uses("actions/checkout@v4")
                .with("submodules", "recursive")
                .build())
            .add_step(JobStep::builder()
                .uses("swatinem/rust-cache@v2")
                .with("key", "${{ join(matrix.targets, '-') }}")
                .build())
            .add_step(JobStep::builder()
                .name("Install cargo-dist")
                .run("${{ matrix.install_dist }}")
                .build())
            .add_step(JobStep::builder()
                .name("Fetch local artifacts")
                .uses("actions/download-artifact@v4")
                .with("pattern", "artifacts-*")
                .with("path", "target/distrib/")
                .with("merge-multiple", true)
                .build())
            .add_step(JobStep::builder().name("Install dependencies").run("${{ matrix.packages_install }}").build())
            .add_step(JobStep::builder()
                .name("Build artifacts")
                .run(r#"# Actually do builds and make zips and whatnot
cargo dist build ${{ needs.plan.outputs.tag-flag }} --print=linkage --output-format=json ${{ matrix.dist_args }} > dist-manifest.json
echo "cargo dist ran successfully""#)
                .build())
            .add_step(JobStep::builder()
                .id("cargo-dist")
                .name("Post-build")
                .shell("bash")
                .run(r#"# Parse out what we just built and upload it to scratch storage
echo "paths<<EOF" >> "$GITHUB_OUTPUT"
jq --raw-output ".upload_files[]" dist-manifest.json >> "$GITHUB_OUTPUT"
echo "EOF" >> "$GITHUB_OUTPUT"
cp dist-manifest.json "$BUILD_MANIFEST_NAME""#)
                .build())
            .add_step(JobStep::builder()
                .name("Upload artifacts")
                .uses("actions/upload-artifact@v4")
                .with("name", "artifacts-build-local-${{ join(matrix.targets, '_') }}")
                .with("path", r#"${{ steps.cargo-dist.outputs.paths }}
${{ env.BUILD_MANIFEST_NAME }}"#)
                .build())
            .build())
        .add_job("build-global-artifacts", Job::builder()
            .needs("plan")
            .needs("build-local-artifacts")
            .runs_on("ubuntu-20.04")
            .env_var("GH_TOKEN", "${{ secrets.GITHUB_TOKEN }}")
            .env_var("BUILD_MANIFEST_NAME", "target/distrib/global-dist-manifest.json")
            .add_step(JobStep::builder()
                .uses("actions/checkout@v4")
                .with("submodules", "recursive")
                .build())
            .add_step(JobStep::builder()
                .name("Install cargo-dist")
                .uses("actions/download-artifact@v4")
                .with("pattern", "artifacts-*")
                .with("path", "target/distrib/")
                .with("merge-multiple", true)
                .build())
            .add_step(JobStep::builder()
                .id("cargo-dist")
                .shell("bash")
                .run(r#"cargo dist build ${{ needs.plan.outputs.tag-flag }} --output-format=json "--artifacts=global" > dist-manifest.json
echo "cargo dist ran successfully"
# Parse out what we just built and upload it to scratch storage
echo "paths<<EOF" >> "$GITHUB_OUTPUT"
jq --raw-output ".upload_files[]" dist-manifest.json >> "$GITHUB_OUTPUT"
echo "EOF" >> "$GITHUB_OUTPUT"
cp dist-manifest.json "$BUILD_MANIFEST_NAME""#)
                .build())
            .add_step(JobStep::builder()
                .name("Upload artifacts")
                .uses("actions/upload-artifact@v4")
                .with("name", "artifacts-build-global")
                .with("path", "${{ steps.cargo-dist.outputs.paths }}
${{ env.BUILD_MANIFEST_NAME }}")
               .build())
            .build())
        .add_job("host", Job::builder()
            .name("host")
            .needs("plan")
            .needs("build-local-artifacts")
            .needs("build-global-artifacts")
            .if_cond("${{ always() && needs.plan.outputs.publishing == 'true' && (needs.build-global-artifacts.result == 'skipped' || needs.build-global-artifacts.result == 'success') && (needs.build-local-artifacts.result == 'skipped' || needs.build-local-artifacts.result == 'success') }}")
            .env_var("GH_TOKEN", "${{ secrets.GITHUB_TOKEN }}")
            .runs_on("ubuntu-20.04")
            .output("val", "${{ steps.host.outputs.manifest }}")
            .add_step(JobStep::builder()
                .uses("actions/checkout@v4")
                .with("submodules", "recursive")
                .build())
            .add_step(JobStep::builder()
                .name("Install cargo-dist")
                .run("curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.14.1/cargo-dist-installer.sh | sh")
                .build())
            .add_step(JobStep::builder()
                .name("Fetch artifacts")
                .uses("actions/download-artifact@v4")
                .with("pattern", "artifacts-*")
                .with("path", "target/distrib/")
                .with("merge-multiple", true)
                .build())
            .add_step(JobStep::builder()
                .id("host")
                .shell("bash")
                .run(r#"cargo dist host ${{ needs.plan.outputs.tag-flag }} --steps=upload --steps=release --output-format=json > dist-manifest.json
echo "artifacts uploaded and released successfully"
cat dist-manifest.json
echo "manifest=$(jq -c "." dist-manifest.json)" >> "$GITHUB_OUTPUT""#)
                .build())
            .add_step(JobStep::builder()
                .name("Upload dist-manifest.json")
                .uses("actions/upload-artifact@v4")
                .with("name", "artifacts-dist-manifest")
                .with("path", "dist-manifest.json")
                .build())
            .build())
        .add_job(
        "publish-homebrew-formula", Job::builder()
            .needs("plan")
            .needs("host")
            .runs_on("ubuntu-20.04")
            .env_var("GH_TOKEN", "${{ secrets.GITHUB_TOKEN }}")
            .env_var("PLAN", "${{ needs.plan.outputs.val }}")
            .env_var("GITHUB_USER", "axo bot")
            .env_var("GITHUB_EMAIL", "admin+bot@axo.dev")
            .if_cond("${{ !fromJson(needs.plan.outputs.val).announcement_is_prerelease || fromJson(needs.plan.outputs.val).publish_prereleases }}")
            .add_step(JobStep::builder()
                .uses("actions/checkout@v4")
                .with("token", "freemasen/homebrew-tap")
                .with("repository", "${{ secrets.HOMEBREW_TAP_TOKEN }}")
                .build())
            .add_step(JobStep::builder()
                .name("Fetch homebrew formulae")
                .uses("actions/download-artifact@v4")
                .with("pattern", "artifacts-*")
                .with("path", "Formula/")
                .with("merge-multiple", true)
                .build())
            .add_step(JobStep::builder()
                .name("Commit formula files")
                .run(r#"git config --global user.name "${GITHUB_USER}"
git config --global user.email "${GITHUB_EMAIL}"
for release in $(echo "$PLAN" | jq --compact-output '.releases[] | select([.artifacts[] | endswith(".rb")] | any)'); do
  filename=$(echo "$release" | jq '.artifacts[] | select(endswith(".rb"))' --raw-output)
  name=$(echo "$filename" | sed "s/\.rb$//")
  version=$(echo "$release" | jq .app_version --raw-output)
  git add "Formula/${filename}"
  git commit -m "${name} ${version}"
done
git push"#)
                .build())
            .build())
        .add_job("announce", Job::builder()
            .needs("plan")
            .needs("host")
            .needs("publish-homebrew-formula")
            .if_cond("${{ always() && needs.host.result == 'success' && (needs.publish-homebrew-formula.result == 'skipped' || needs.publish-homebrew-formula.result == 'success') }}")
            .runs_on("ubuntu-20.04")
            .env_var("GH_TOKEN", "${{ secrets.GITHUB_TOKEN }}")
            .add_step(JobStep::builder()
                .uses("actions/checkout@v4")
                .with("submodules", "recursive")
                .build())
            .add_step(JobStep::builder()
                .name("Download GitHub Artifacts")
                .uses("actions/download-artifact@v4")
                .with("pattern", "artifacts-*")
                .with("path", "artifacts")
                .with("merge-multiple:", true)
                .build())
            .add_step(JobStep::builder()
                .name("Cleanup")
                .run(r#"# Remove the granular manifests
rm -f artifacts/*-dist-manifest.json"#)
                .build())
            .add_step(JobStep::builder()
                .name("Create GitHub Release")
                .with("tag", "${{ needs.plan.outputs.tag }}")
                .with("name", "${{ fromJson(needs.host.outputs.val).announcement_title }}")
                .with("body", "${{ fromJson(needs.host.outputs.val).announcement_github_body }}")
                .with("prerelease", "${{ fromJson(needs.host.outputs.val).announcement_is_prerelease }}")
                .with("artifacts", "artifacts/*")
                .build())
            .build())
        .build();
    println!("{}", serde_yml::to_string(&wf).unwrap())
}
